InnoDB 는?
- MySQL 에서 사용할 수 있는 스토리지 엔진중 거의 유일하게 레코드기반의 잠금을 제공함.
- 그 덕에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어남.
  
Primary 키에 의한 클러스터링
- InnoDB의 모든 테이블은 Primary Key 값의 순서대로 디스크에 저장된다.
- Primary Key가 클러스터링 인덱스이기에 Primary Key를 활용한 레인지 스캔은 상당히 빨리 처리된다.

👀 클러스터링 인덱스?
- 테이블생성시 자동으로 생성되는 인덱스
- primary key 로 select 조회시 겁나빠름

외래키 지원
- 외래키의 존재에 주의하지 않을시 수동으로 데이터를 적재하거나 스키마 변경 등의 관리 작업이 실패할 수 있다.
- foreign_key_checks 시스템 변수를 0으로 설정하면 외래키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.
- SET foregin_key_checks=OFF;
- 이거 하면 ON DELETE CASCADE도 무시된다. 그러니 부모테이블 레코드를 삭제했다면 자식테이블 레코드도 삭제할 것.
  
MVCC
- 일반적으로 레드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- InnoDB는 언두로그를 이용해 이 기능을 구현

👀 레코드 레벨의 트랜잭션이란?
- 레코드 레벨의 트랜잭션은 데이터베이스의 한 개 또는 여러 개의 레코드(행, Row)에 대해 수행되는 단위 작업(Transaction) 을 의미합니다. 이는 레코드 단위로 격리성을 보장하여, 하나의 트랜잭션이 특정 레코드를 수정하는 동안에도 다른 트랜잭션이 동일 테이블의 다른 레코드를 자유롭게 수정할 수 있도록 합니다.
- 이 방식은 데이터베이스의 동시성을 향상시키고, 불필요한 락(Lock)으로 인한 병목 현상을 방지하는 데 중요한 역할을 합니다.
- 만약 작업중인 레코드를 조회하면 MySQL 서버의 시스템 변수 transaction_isolation에 설정된 격리수준 레벨에 따라 반환되는 데이터가 다를 수 있음

👀 언두로그란?
- Undo Log는 트랜잭션이 변경하기 전의 데이터를 저장하는 로그로, MySQL(InnoDB)에서 MVCC(다중 버전 동시성 제어, Multi-Version Concurrency Control) 및 트랜잭션 롤백을 지원하기 위한 핵심 요소
- 간단히 말해, Undo Log는 “되돌릴 수 있는 변경 사항의 기록”을 남겨, 데이터가 변경되기 전 상태를 복원할 수 있도록 합니다.

잠금 없는 일관된 읽기
- isolation 이 Serializable 이 아니라면 insert와 연결되지 않은 select 작업은 잠금대기없이 바로 실행됨 
- 그러므로써 읽기로 인한 잠금상태 를 설정하지 않게되고 성능향상

자동 데드락감지 
- Mysql은 데드락 테이블이 있고 데드락 발생된 트랜잭션 찾아서 강제종료
- 언두로그 양이 적은 트랜잭션을 우선순위로 강제종료

자동화된 장애 복구
- InnoDB는 부팅시 자동복구
- 하드웨어나 디스크 문제로 자동화된 복구를 못할때도 존재
- 이럴땐 innodb_force_recovery 시스템변수 설정으로 mysql 서버 시작하자.
- 단계가 1~6 존재하고 단계가 높을수록 심각한 상태이고 복구가 어려울수 있다.
  - 로그파일 손상 => 6
  - 데이터 파일 손상 => 1
  - 뭔지 모르겠으면 1~6 변경한채로 부팅시도 ㄱ
- 만약 부팅이 성공적으로 되고 innodb 테이블이 인식된다면 데이터 백업 => 백업데이터를 활용해 DB와 테이블을 다시생성 하자.
- InnoDB의 복구를 이용하는거보다 마지막 백업으로 데이터베이스 새로 구축하고 바이너리 로그를 사용해 최대한 장애시점까지의 데이터를 복구해라
  
버퍼풀
- InnoDB 스토리지 엔진에서 가장 핵심적인 부분
- 디스크의 데이터파일이나 인덱스 정보를 메모리에 캐시해두는 공간
- 쓰기작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼역할도함
- 크기설정 : 
  - 운영체제와 각 클라이언트 스레드가 사용할 메모리 양도 충분히 고려해서 설정해라
  - 8GB라면 50% 그이상이라면 차차 올려보던가식
- 버퍼풀 크기설정 가능 : innodb_buffer_pool_size -> 크리티컬하니까 한가할때 하자.
- 가능하면 버퍼풀의 크기를 줄이는 변경은 하지말자.
- 버퍼풀 인스턴트당 5GB정도가 되게 버퍼풀 인스턴스를 설정하자. 기존 8개
- LRU, MRU 결합된 형태로 데이터 페이지 캐시
- InnoDB 버퍼 풀은 데이터 캐시와 쓰기 버퍼링이라는 두가지 용도가 있는데 버퍼풀의 메모리 공간만 단순히 늘리는건 데이터 캐시 기능만 향상시키는것.


👀 레코드버퍼 
- 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용되는 공간을 말함
- 커넥션이 많고 사용하는 테이블도 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 꽤 많이 필요해질 수도 있다.
- 레코드 버퍼가 사용할 레코드 버퍼 공간은 별도 설정가능(5.7이상), 커넥션 갯수와 커넥션에서 읽고 쓰는 테이블의 갯수에 따라 정해짐
- 이버퍼 공간은 동적으로 해제되기도 하므로 정확히 필요한 메모리 공간크기를 계산할 수 가 없다.

버퍼풀과 리두로그 관계
- 버퍼풀에는 클린페이지(변경없는)와 더티페이지(변경된)를 갖고 있다.
- 언젠가는 버퍼풀의 더티페이지를 디스크로 써야함
- Log Sequence Number (LSN)은 순환되어 재사용 되는 로그의 번호, 로그포지션은 계속해서 증가된 값을 갖게된다. 
- 최근 엔트리의 LSN과 마지막 LSN의 차이는 결국 활성 리두 로그 공간의 크기

플러시 리스트 플러시
- 백그라운드 동작
- 리두공간의 재활용을 위해 필요함
- 오래된 더티페이지가 디스크로 동기화 되는데 사용
- 더티페이지를 디스크로 동기화 하는 스레드를 클리너 스레드라고 함
- innodb_page_cleaners 시스템 변수를 통해 클리너 스레드의 갯수를 조정할 수 있게 함.

어댑티브 플러시 
- 리두로그의 증가속도를 분석해 적절한 수준의 더티페이지가 버퍼 풀에 유지될 수 있도록 디스크 쓰기함

LRU 리스트 플러시
- LRU 리스트에서 사용빈도가 낮은 데이터 페이지들을 제거
- LRU 리스트의 끝부분부터 시스템 변수에 설정된 갯수만큼의 페이지 스캔하고 더티페이지는 디스크에 동기화
- 클린 페이지는 프리리스트로 페이지 옮김

버퍼 풀 상태 백업 및 복구
- 버퍼 풀이 성능에 큰영향을 미침
- 버퍼풀 덤프 및 적재 기능 도입됨 (5.6 부터)
- 서버 다시 시작시 버퍼 풀상태 복구함

Double Write Buffer
- 리두로그 공간의 낭비를 막기위해 페이지의 변경된 내용만 기록함
- 이처럼 파셜페이지, 톤페이지와 같은 일부만 기록하는 문제가 발생하면 하드웨어의 오작동이나 시스템 비정상 종료 등의 문제발생
- 더티페이지를 디스크로 플러시 할때 한번의 디스크 쓰기로 테이블 스페이스의 DoubleWrite Buffer에 기록한다




