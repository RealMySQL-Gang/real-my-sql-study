## 4.2 InnoDB 스토리지 엔진 아키텍처
InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, <br>
그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다. <br>

<img width="600" alt="image" src="https://github.com/user-attachments/assets/e11ac2af-33b3-474d-be05-bdf507288038"> <br>

<br>

### 4.2.1 프라이머리 키에 의한 클러스터링
InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다. <br>
즉, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며, <br>
모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.

- 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다. <br>
  결과적으로 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.
- MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않기 때문에 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다. <br>
  또한, 프라이머리 키를 포함한 모든 인덱스는 물리적인 레코드의 주소 값(ROWID)을 가진다.

<br>

### 4.2.2 외래 키 지원
부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, <br>
변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하다.

- InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.
- 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 외래 키의 존재에 주의하는 것이 좋다.
- `foreign_key_checks` 시스템 변수를 `OFF`로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다. <br>
  하지만 반드시 부모 테이블과 자식 테이블의 일관성을 맞춰준 후 다시 외래 키 체크 기능을 활성화하도록 하자.

<br>

### 4.2.3 MVCC(Multi Version Concurrency Control)
일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, 잠금을 사용하지 않는 일관된 읽기를 제공한다. <br>
InnoDB는 **Undo Log**를 이용해 이 기능을 구현한다. <br>

<br>

```
e.g.

데이터 insert 작업 후 commit O, update 작업 후 commit X
update 문장이 실행되면 InnoDB의 버퍼 풀은 새로운 값을 가지게 되고, 변경 전 값은 언두 로그로 복사한다.
이때 데이터를 조회하면? => 트랜잭션 격리 수준에 따라 결과가 달라진다.

`READ_UNCOMMITTED`인 경우에는 InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다.
`READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE` 인 경우에는 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환한다.

이 상태에서 commit을 실행하면 InnoDB는 지금의 상태를 영구적인 데이터로 만든다.
하지만 rollback을 실행하면 InnoDB는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제한다. 
```

<br>

#### 💡 참고

트랜잭션 격리 수준 | 설명
:--- | :---
READ_UNCOMMITTED | 커밋되지 않은 데이터를 읽는다.
READ_COMMITTED | 커밋된 데이터만 읽을 수 있다.
REPEATABLE_READ | 동일 트랜잭션 내에서 동일한 데이터의 결과를 보장한다.
SERIALIZABLE | 트랜잭션을 직렬화된 순서로 실행한다. SELECT 문도 공유 잠금을 획득한다.

- 격리 수준이 높을수록 데이터 일관성은 높아지지만 성능 저하가 발생할 수 있다.

<br>

### 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent READ)
InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다. <br>
특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않는다. <br>
InnoDB에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.

<br>

### 4.2.5 자동 데드락 감지
InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다. <br>
데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아 그 중 하나를 강제 종료한다. <br>

- 어느 트랜잭션을 먼저 강제 종료할 것인지를 판단하는 기준은 언두 로그 양이다. 일반적으로 언두 로그 레코드를 더 적게 가진 트랜잭션이 롤백의 대상이 된다.
- `innodb_table_locks` 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금까지 감지할 수 있다.
- `innodb_deadlock_detect` 시스템 변수를 `OFF`로 설정하면 데드락 감지 스레드는 작동하지 않는다.
- `innodb_lock_wait_timeout` 시스템 변수는 초 단위로 설정하며, 잠금을 설정한 시간 동안 획득하지 못하면 쿼리는 실패하고 에러를 반환한다.

<br>

### 4.2.6 자동화된 장애 복구
InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행한다.

- 이 단계에서 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버가 종료된다. <br>
  이때는 MySQL 서버의 설정 파일에 `innodb_force_recovery` 시스템 변수를 설정해서 MySQL 서버를 시작해야 한다. <br>
  값이 커질수록 복구 가능성이 적어진다.
  - `1`: 로그 파일 복구만 수행 (기본 복구 수준)
  - `2`: 버퍼 풀에서 수정된 페이지 무시
  - `3`: 일관성 검사 중단 (테이블스페이스 스캔 무시)
  - `4`: 언두 로그 적용 건너뛰기 (롤백 수행 안함)
  - `5`: 복구 시 언두 로그 삭제 (일관성 무시)
  - `6`: 모든 복구 작업 중단 -> 강제 마운트 (읽기 전용)
- 마지막 풀 백업 시점으로부터 장애 시점까지의 바이너리 로그가 있다면 <br>
  InnoDB의 복구를 이용하는 것보다 풀 백업과 바이너리 로그로 복구하는 편이 데이터 손실이 더 적을 수도 있다.

<br>

### 4.2.7 InnoDB 버퍼 풀 ⭐️
디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간 + 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할 

<br>

**1️⃣ 버퍼 풀의 크기 설정**
- MySQL 5.7부터 InnoDB 버퍼 풀의 크기를 동적으로 조절 가능
- 가능하면 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 상황을 봐 가면서 증가시키는 것이 최적이다.
  - 운영체제의 전체 메모리 공간이 8GB 미만일 경우 전체 메모리의 50% 정도로 설정한다.
  - 8GB 이상이라면 버퍼 풀의 크기를 전체 메모리의 50%에서 시작해서 조금씩 올려가며 최적점을 찾는다.
  - 50GB 이상이라면, 대략 15GB ~ 30GB 정도를 운영체제와 다른 응용 프로그램을 위해 남겨두고 나머지를 버퍼 풀로 할당한다.
- `innodb_buffer_pool_size` 시스템 변수로 크기를 설정할 수 있다.
- 버퍼 풀의 크기 변경은 크리티컬하므로 가능하면 MySQL 서버가 한가한 시점을 골라서 진행하는 것이 좋다.
  - 버퍼 풀을 더 크게 변경하는 작업은 시스템 영향도가 크지 않지만, 줄이는 작업은 영향이 매우 크니 주의하자.
- InnoDB 버퍼 풀은 내부적으로 128MB 청크 단위로 쪼개어 관리되는데, 이는 버퍼 풀의 크기를 줄이거나 늘리기 위한 단위 크기로 사용된다.
- [버퍼 풀 크기 설정 매뉴얼](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool-resize.html)

<br>

**2️⃣ 버퍼 풀의 구조** <br>
InnoDB 스토리지 엔진은 버퍼 풀의 메모리 공간을 페이지 크기(`innodb_page_size`)의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다. 버퍼 풀의 페이지 크기 조각을 관리하기 위해 3개의 자료 구조를 관리한다.

1. **LRU**(Least Recently Used) 리스트: 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 유지해서 디스크 읽기를 최소화 <br>

   <img width="400" alt="image" src="https://github.com/user-attachments/assets/23c50b4b-d1bd-4ec9-a618-90345689aadb"> <br>

   'Old 서브리스트' 영역은 Least Recently Used 형태, 'New 서브리스트' 영역은 Most Recently Used 형태 <br>

    ```
   <InnoDB 스토리지 엔진에서 데이터를 찾는 과정>

   1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
       A. InnoDB 어댑티브 해시 인덱스(자주 사용되는 값을 해시로 사용) 이용
          [참고] https://tech.kakao.com/posts/319
       B. 해당 테이블의 인덱스(B-Tree) 이용
       C. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
   2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
   3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
   4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(age)가 부여되며,
       버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고(aging) 결국 해당 페이지는 버퍼 풀에서 제거된다.
       버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화되어 다시 젊어지고 MRU의 헤더 부분으로 옮겨진다.
   5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가

   => 처음 한 번 읽힌 데이터 페이지가 이후 자주 사용된다면 그 데이터 페이지는 MRU 영역에서 계속 살아남게 되고,
      반대로 거의 사용되지 않는다면 LRU의 끝으로 밀려나 결국은 InnoDB 버퍼 풀에서 제거될 것이다.
   ```
  
2. **플러시(Flush)** 리스트: 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리

   - 디스크에서 읽은 상태 그대로 전혀 변경이 없다면 플러시 리스트에 관리되지 않는다.
   - 한 번 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록되어야 한다.
   - 데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다.
   - InnoDB 스토리지 엔진은 체크포인트를 발생시켜 디스크의 리두 로그와 데이터 페이지의 상태를 동기화하게 된다.

3. **프리(Free)** 리스트: 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록

   - 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.
  
<br>

**3️⃣ 버퍼 풀과 리두 로그** <br>
InnoDB 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 두 가지 용도가 있다. <br>
이때 버퍼 풀의 메모리 공간을 늘리는 것은 데이터 캐시 기능을 향상시키는 것이고, <br>
쓰기 버퍼링 기능까지 향상시키려면 InnoDB 버퍼 풀과 리두 로그와의 관계를 이해해야 한다. 

![image](https://github.com/user-attachments/assets/25422882-13e7-432a-bfe3-1f3a94629a65) <br>

- InnoDB 버퍼 풀은 클린 페이지(디스크에서 읽은 상태로 전혀 변경되지 않음)와 더티 페이지(변경된 데이터를 가짐)를 가지고 있다.
- 리두 로그 파일의 공간은 계속 순환되면서 재사용되고, 매번 기록될 때마다 로그 포지션은 계속 증가된 값인 LSN(Log Sequence Number)을 갖게 된다.
- InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화한다.
- InnoDB 버퍼 풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지고, 체크포인트가 발생하면 체크포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화되어야 한다.
