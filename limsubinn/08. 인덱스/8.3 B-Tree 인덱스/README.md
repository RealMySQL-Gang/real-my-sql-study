## 8.3 B-Tree 인덱스
데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로, 가장 먼저 도입된, 가장 범용적인 목적으로 사용되는 알고리즘이다. <br>
일반적으로 DBMS에서는 주로 B+-Tree 또는 B*-Tree 알고리즘이 사용된다.
<br>

컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지한다.

<br>

### 8.3.1 구조 및 특성
트리 구조의 최상위에 하나의 "루트 노드"가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다. <br>
트리 구조의 가장 하위에 있는 노드를 "리프 노드"라 하고, 트리 노드에서 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 "브랜치 노드"라고 한다. <br>
데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, <br>
인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다. <br>
<br>

<img width="800" alt="image" src="https://github.com/user-attachments/assets/4d65be2e-8b47-484d-9ff2-6fa8f49a254e"> <br>
<br>

인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않고 임의의 순서로 저장되어 있다. <br>

> 대부분의 RDBMS의 데이터 파일에서 레코드는 임의의 순서로 저장된다. <br>
> 하지만 InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.

인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. <br>
이를 위해 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다. <br>
<br>

![image](https://github.com/user-attachments/assets/4ccf6224-c4a6-4508-937f-d385d32113a4) <br>
<br>

위의 그림은 **MyISAM 테이블**의 인덱스와 데이터 파일의 관계를 보여준다. <br>
"레코드 주소"는 레코드가 테이블에 INSERT된 순번이거나 데이터 파일 내의 위치(Offset)이다. <br>
세컨더리 인덱스가 **물리적인 주소**를 가진다. <br>

> MyISAM 테이블은 프라이머리 키에 의한 클러스터링 없이 데이터 파일이 Heap 공간처럼 활용된다. (INSERT 순서대로 데이터 파일에 저장) <br>
> 그리고 저장되는 레코드는 모두 ROWID라는 물리적인 주솟값을 가지는데, 프라이머리 키와 세컨더리 인덱스는 모두 데이터 파일에 저장된 레코드의 ROWID 값을 포인터로 가진다.
> - 고정 길이 ROWID: ROWID 값으로 4바이트 정수를 사용하고, 레코드가 INSERT된 순번이 ROWID로 사용된다.
> - 가변 길이 ROWID: 첫 번째 바이트는 ROWID의 길이를 저장하는 용도로 사용하고 나머지 공간은 실제 ROWID를 저장하는 데 사용한다. 데이터 파일에서 레코드의 위치(offset)가 ROWID로 사용된다.

![image](https://github.com/user-attachments/assets/3097c123-5dca-4fed-bb81-34e6fa200577) <br>
<br>

위의 그림은 **InnoDB 테이블**의 인덱스와 데이터 파일의 관계를 보여준다. <br>
프라이머리 키가 ROWID의 역할을 하고, 프라이머리 키를 주소처럼 사용하기 때문에 **논리적인 주소**를 가진다. <br>
인덱스에 저장되어 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, <br>
프라이머리 키 인덱스의 리프 페이지에 저장되어 있는 레코드를 읽는다. <br>
즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 <br>
반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.

<br>

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제
<br>

**1️⃣ 인덱스 키 추가**
<br>

B-Tree에 새로운 키 값이 저장될 때에는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다. <br>
저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다. <br>
이때 리프 노드가 꽉 차서 더이상 저장할 수 없을 땐 리프 노드가 분리되어야 해서 상위 브랜치 노드까지 처리의 범위가 넓어진다.
<br>

B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다. <br>
대부분의 비용은 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 해서 걸리는 시간이다.
<br>

MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블은 INSERT 문장 실행 시 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다. <br>
InnoDB 스토리지 엔진은 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제하고, <br>
보조 인덱스에 대해서는 체인지 버퍼를 이용하여 인덱스 키 추가 작업을 지연시킬 수 있다. 

<br>

**2️⃣ 인덱스 키 삭제**
<br>

해당 키 값이 저장된 B-Tree의 리프 노드를 찾아 삭제 마크를 한다. <br>
이렇게 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다. <br>
인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 디스크 I/O가 필요한 작업이다. <br>
MySQL 5.5 이상 버전의 InnoDB 스토리지 엔진에서는 이 작업 또한 버퍼링되어 지연 처리될 수 있다.

<br>

**3️⃣ 인덱스 키 변경**
<br>

인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로, B-Tree의 경우 단순히 인덱스상의 키 값만 변경하는 것이 불가능하다. <br>
먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.

<br>

**4️⃣ 인덱스 키 검색**
<br>

B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행한다. => "트리 탐색" <br>
인덱스 트리 탐색은 SELECT뿐만 아니라 UPDATE나 DELETE를 처리하기 위해 항상 해당 레코드를 먼저 검색해야 할 경우에도 사용된다. <br>
B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다. <br>
부등호 비교 조건에서도 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 사용할 수 없다. <br>
또한, 인덱스의 키 값에 변형이 가해진 후 비교되는 경우 사용할 수 없다. (함수나 연산을 수행한 결과로 정렬하거나 검색하는 작업) 
<br>

InnoDB 스토리지 엔진에서 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있다. <br>
따라서 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.

<br>

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
<br>

**1️⃣ 인덱스 키 값의 크기**
<br>

InnoDB 스토리지 엔진에서 디스크에 데이터를 저장하는 가장 기본 단위를 페이지라고 한다. <br>
페이지는 디스크의 모든 읽기 및 쓰기 작업의 최소 단위가 된다. <br>
또한, 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다. <br>
인덱스도 페이지 단위로 관리되며, 루트 / 브랜치 / 리프 노드를 구분한 기준이 페이지 단위이다.
<br>

일반적으로 DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. <br>
이때 인덱스의 페이지 크기와 키 값의 크기에 따라 자식 노드의 개수가 결정된다. 
<br>

예를 들어, 인덱스의 키가 16바이트, 자식 노드 주소 영역이 평균적으로 12바이트로 구성된다고 가정해보자. <br>
이때 하나의 인덱스 페이지(16KB)에 `16 * 1024 / (16 + 12) = 585`개를 저장할 수 있다. <br>
자식 노드를 585개를 가질 수 있는 B-Tree가 되는 것이다. <br>
인덱스 키 값의 크기가 32바이트(2배)로 늘어났다고 가정하면, 한 페이지에 인덱스 키를 `16 * 1024 / (32 + 12) = 372`개 저장할 수 있다. <br>
레코드 500개를 읽을 때 전자는 인덱스 페이지 한 번으로 해결될 수 있지만, 후자는 최소 2번 이상 디스크로부터 읽어야 한다. <br>
결국 **인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다**는 것을 의미한다.
<br>

인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 의미한다. <br>
인덱스를 캐시해 두는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 크기가 제한적이기 때문에 <br>
하나의 레코드를 위한 인덱스 크기가 커질수록 메모리에 캐시해 둘 수 있는 레코드 수는 줄어든다. <br>
이는 결국 메모리의 효율이 떨어지는 결과를 가져온다.

<br>

**2️⃣ B-Tree 깊이**
<br>

인덱스 키 값의 크기가 커질수록 하나의 인덱스 페이지가 담을 수 있는 키 값의 개수가 적어지고, <br>
때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다.
<br>

위의 예시를 다시 한번 살펴보자. <br>
만약 인덱스의 B-Tree 깊이가 3인 경우, 키 값이 16바이트인 경우에는 최대 2억(585^3)개 정도의 키 값을 담을 수 있지만, <br>
키 값이 32바이트로 늘어나면 5천만(372^3)개로 줄어든다. 

<br>

**3️⃣ 선택도(기수성)**
<br>

모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다. <br>
인덱스 키 값 가운데 중복된 값이 많아질수록 기수성은 낮아지고, 선택도 또한 떨어진다. <br>
인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 빠르게 처리된다. <br>

> 선택도가 좋지 않다고 하더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 나은 경우도 있다.

<br>

**4️⃣ 읽어야 하는 레코드의 건수**
<br>

인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 읽는 것보다 높은 비용이 드는 작업이다. <br>
인덱스를 이용한 읽기의 손익 분기점이 얼마인지 판단할 필요가 있다. <br>
일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 <br>
테이블에서 직접 레코드 1건을 읽는 것보다 4-5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다. <br>
즉, 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20-25%를 넘어서면 <br>
인덱스를 이용하지 않고 테이블을 모두 직접 읽어 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.

<br>

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기
어떤 경우에 인덱스를 사용하게 유도할지, 또는 사용하지 못하게 할지 판단하려면 
MySQL의 각 스토리지 엔진이 어떻게 인덱스를 이용(경유)해서 실제 레코드를 읽어 내는지 알아야 한다.

<br>

**1️⃣ 인덱스 레인지 스캔**
<br>

대표적인 인덱스의 접근 방식이다. 다른 두 가지 방법에 비해 빠르다.

<br>

<img width="500" alt="image" src="https://github.com/user-attachments/assets/00d37803-3930-43cc-bc11-1c2bb523d610"> <br>
위 그림은 실제 인덱스만을 읽는 경우의 레인지 스캔 과정이다. <br>
인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다. <br>
검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현한다. <br>
루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야 필요한 레코드의 시작 지점을 찾을 수 있다. <br>
시작해야 할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다. <br>
이처럼 차례대로 쭉 읽는 것을 스캔이라고 표현한다. <br>
만약 스캔하다가 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아 다시 스캔한다.

<br>

<img width="500" alt="image" src="https://github.com/user-attachments/assets/42dc9884-667a-4474-ba10-08a60df26c56"> <br>
위 그림은 실제 데이터 파일의 레코드를 읽어와야 하는 경우의 레인지 스캔 과정이다. <br>
B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 그 지점부터 필요한 방향(오름차순 또는 내림차순)으로 인덱스를 읽어 나간다. <br>
어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 형태로 레코드를 가져온다. <br>
이는 인덱스 자체의 정렬 특성 때문에 자동으로 그렇게 된다. <br>
또한, 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다. <br>
이때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한 번씩 일어난다. <br>
그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류된다. <br>
인덱스를 통해 읽어야 할 데이터 레코드가 20~25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 처리 방식이 된다.

<br>

```
💡 정리
1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. => 인덱스 탐색
2. 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. -> 인덱스 스캔
3. 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.
```
쿼리가 필요로 하는 데이터에 따라 3번 과정은 필요하지 않을 수도 있는데, 이를 커버링 인덱스라고 한다. <br>
커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 성능은 그만큼 빨라진다. <br>

> 커버링 인덱스? <br>
> 쿼리를 충족시키는데 필요한 모든 데이터를 갖고 있는 인덱스

<br>

```sql
mysql> SHOW STATUS LIKE 'Handler_%';
```
- `Handler_read_key`: 1번 단계가 실행된 횟수
- `Handler_read_next`: 2번 단계로, 인덱스 정순으로 읽은 레코드 건수
- `Handler_read_prev`: 2번 단계로, 인덱스 역순으로 읽은 레코드 건수
- `Handler_read_first`: 인덱스의 첫 번째 레코드를 읽은 횟수
- `Handler_read_last`: 인덱스의 마지막 레코드를 읽은 횟수

<br>

**2️⃣ 인덱스 풀 스캔**
<br>

인덱스의 처음부터 끝까지 모두 읽는 방식이다. <br>
대표적으로 쿼리의 조건절에 사용된 컬럼이 첫 번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다. <br>
e.g. 인덱스는 (A, B, C) 컬럼의 순서로 만들어져 있지만 쿼리의 조건절은 B 컬럼이나 C 컬럼으로 검색하는 경우

<br>

<img width="500" alt="image" src="https://github.com/user-attachments/assets/0088401e-31f0-4748-b165-1de711737fb8"> <br>
인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 후, 인덱스의 리프 노드를 연결하는 Linked List를 따라서 처음부터 끝까지 스캔한다. <br>
인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다. <br>
인덱스에 포함된 컬럼만으로 쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없기 때문이다.

<br>

**3️⃣ 루스 인덱스 스캔**
<br>

말 그대로 느슨하게 또는 듬성듬성하게 레코드를 읽는 것을 의미한다. <br>
인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요하지 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다. <br>
일반적으로 `GROUP BY` 또는 집합 함수 가운데 `MAX()` 또는 `MIN()` 함수에 대해 최적화를 하는 경우 사용된다.
<br>

e.g.
```sql
mysql> SELECT dept_no, MIN(emp_no)
       FROM dept_emp
       WHERE dept_no BETWEEN 'd002' AND 'd004'
       GROUP BY dept_no;
```
![image](https://github.com/user-attachments/assets/f7dffe30-b0dc-4a7f-b736-6ca8c1ef718d) <br>
dept_emp 테이블은 dept_no와 emp_no라는 두 개의 컬럼으로 인덱스가 생성되어 있다. <br>
또한, 이 인덱스는 (dept_no, emp_no) 조합으로 정렬까지 되어 있어 dept_no 그룹 별로 첫 번째 레코드의 emp_no 값만 읽으면 된다. <br>
즉, 인덱스에서 WHERE 조건을 만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저가 알고 있기 때문에 <br>
조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 넘어간다.

<br>

**4️⃣ 인덱스 스킵 스캔**
<br>

데이터베이스 서버에서 인덱스는 값이 정렬되어 있으며, 이로 인해 인덱스를 구성하는 컬럼의 순서가 매우 중요하다. <br>
예를 들어, employees 테이블에 (gender, birth_date) 와 같은 인덱스를 생성했다면, <br>
이 인덱스를 사용하기 위해 WHERE 조건절에 gender 컬럼과 birth_date 컬럼에 대한 비교 조건이 필수적이다.
<br>

MySQL 8.0부터는 옵티마이저가 gender 컬럼을 건너뛰어 birth_date 컬럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입되었다. <br>
이는 WHERE 조건절의 검색을 위해 사용 가능하도록 루스 인덱스 스캔에 비해 용도가 훨씬 넓어졌다.

<br>

```sql
mysql> SELECT gender, birth_date
       FROM employees
       WHERE birth_date >= '1965-02-01';
```
<img width="371" alt="image" src="https://github.com/user-attachments/assets/e412ca4e-3fae-4b71-ac26-ba58805149a0"> <br>
MySQL 옵티마이저는 우선 gender 컬럼에서 유니크한 값을 모두 조회해서 <br>
주어진 쿼리에 gender 컬럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다. <br>
내부적으로 위와 같이 2개의 쿼리를 실행하는 것과 비슷한 형태의 최적화를 실행하게 되는 것이다.
```sql
mysql> SELECT gender, birth_date FROM employees WHERE gender = 'M' AND birth_date >= '1965-02-01';
mysql> SELECT gender, birth_date FROM employees WHERE gender = 'F' AND birth_date >= '1965-02-01';
```

<br>

인덱스 스킵 스캔은 새로 도입된 기능이어서 아직 단점이 있다.
- WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야 함
  - 만약 유니크한 값의 개수가 매우 많다면 MySQL 옵티마이저는 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해진다.
    그래서 쿼리의 처리 성능이 오히려 더 느려질 수도 있다.
- 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 함(커버링 인덱스)
  - 인덱스에 포함된 컬럼 이의외 나머지 컬럼도 필요로 하기 때문에 인덱스 스킵 스캔을 사용하지 못하고 풀 테이블 스캔으로 실행 계획을 수립한다.
 
<br>
