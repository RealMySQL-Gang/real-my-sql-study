# 4.2 InnoDB 스토리지 엔진 아키텍처
<img width="537" alt="Image" src="https://github.com/user-attachments/assets/a3e4e2da-da3c-4eb5-96e8-0da1ee7812a6" />

### InnoDB 스토리지 엔진
- 레코드 기반 잠금 제공
    - 높은 동시성 처리 가능
    - 안정적
    - 성능 뛰어남


## 4.2.1 프라이머리 키에 의한 클러스터링
- InnoDB의 모든 테이블 -> 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장
    - 프라이머리 키 값 순서대로 디스크에 저장
    - 실행 계획에서 기본키는 다른 보조 인덱스보다 비중이 높게 설정된다.
- 세컨더리 인덱스 -> 라이머리 키의 값을 논리적인 주소로 사용
- MyISAM -> 클러스터링 키 지원 X
    - 프라이머리 키와 세컨더리 인덱스의 구조적 차이 X
    - 프라이머리 키 == 유니크 제약을 가진 세컨더리 인덱스
    - 모든 인덱스는 물리적인 레코드의 주소 값(ROWID)를 가짐

## 4.2.2 외래 키 지원
- InnoDB 스토리지 엔지 레벌에서만 외래키 지원
    - MyISAM, MEMORY 테이블에서는 외래키 사용 X
- 외래 키 체크 기능 비활성화 방법
  ```sql
  SET foreign_key_checks=OFF;
  ```
    - `ON DELETE CASCADE`, `ON UPDATE DASCADE` 무시됨
    - 외래 키 관계가 사라지는건 아님. 다만 외래 키 제약 조건 검증을 안할 뿐.

## 4.2.3 MVCC(Multi Version Concurrency Control)



## 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

## 4.2.5 자동 데드락 감지

## 4.2.6 자동화된 장애 복구

## 4.2.7 InnoDB 버퍼 풀
디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간 
- InnoDB 스토리지 엔진에서 가장 핵심적인 부분
- 쓰기 작업을 지연시켜 일괄 작업으로 처리 가능하게 해주는 **버퍼 역할**
- 변경된 데이터를 모아서 처리 -> 랜덤 디스크 작업의 횟수를 줄임
- **캐시 역할**: 디스크에 저장된 데이터 파일이나 인덱스 페이지를 메모리에 보관해, 자주 사용되는 데이터를 빠르게 접근할 수 있도록 합니다.
- **버퍼 역할**: 트랜잭션 수행 시 변경된(Dirty) 페이지들을 메모리에 임시로 저장해 두었다가, 나중에 디스크에 기록(Flushing)하는 버퍼 역할도 수행합니다.

### 4.2.7.1 버퍼 풀의 크기 설정
- 운영체제의 각 클라이언트 스레드가 사용할 메모리 고려해서 설정해야함
    - 스레드 스택이나 힙 같은 OS 레벨의 메모리 영역
- MySQL 서버 내 메모리를 필요로 하는 부분은 크게 없음
    - 하지만 독특한 경우 **레코드 버퍼**가 상당한 메모리를 사용하기도 함
        - 레코드 버퍼: 각 클라이언트 세션에서 데이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간
        - 커넥션이 많고, 사용하는 테이블이 많은 경우
    - MySQL 서버가 사용하는 레코드 버퍼 공간은 별도로 설정 못함
        - 전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 데이블의 개수에 따라 결정
        - 동적으로 해제되기도 함
- MySQL5.7부터 InnoDB 버퍼 풀의 크기 동적으로 조절할 수 있게 개선됨.
    - InnoDB 버퍼 풀의 크기를 작은 값으로 설정 -> 필요에 따라 증가시키면서 사용하는 방법이 좋다.
    - 레코드 버퍼 공간 별로 설정 된다는 뜻 아님

- InnoDB 버퍼 풀 크기 설정 방법
    1. 이미 MySQL 서버를 사용하고 있는 경우
        - 서버의 메모리 설정을 기준으로 InnoDB 버퍼 풀의 크기 조정
    2. 처음으로 MySQL 서버 준비
        - 공간이 8GB 미만인 경우
            - 50% 정도만 InnoDB 버퍼 풀로 설정
            - 나머지 메모리 공간 -> MySQL 서버와 운영체제, 다른 프로그램 사용 공간으로 확보
        - 공간이 8GB 이상
            - 50%를 InnoDB 버퍼 풀로 설정 -> 조금씩 올려주면서 최적점 찾기
        - 공간이 50GB 이상
            - 15GB ~ 30GB 정도  MySQL 서버와 운영체제, 다른 프로그램 사용 공간으로 확보
            - 나머지는 전부 InnoDB 버퍼 풀로 할당
    - `innodb_buffer_pool_size`로 크기 설정 가능
    - 버퍼 풀 변경은 크리티컬한 변경 -> MySQL 서버가 한가할 때 하자!
    - 버퍼 풀 크기 줄이는 작업은 지양하자!
        - 늘리는건 시스템 영향도 안큼
        - 줄이는건 서비스 영향도가 매우 큼
    - InnoDB 버퍼 풀 변경 단위 크기: 128MB
    - [버퍼 풀 크기 설정 메뉴얼](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool-resize.html) 

### 버퍼 풀 인스턴스
- InnoDB 버퍼 풀(데이터 캐시 역할을 하는 메모리 영역)을 여러 개의 하위 영역으로 나눈 것
- 내부 잠금 경합 문제를 줄여줌
- 기본적으로 8개로 초기화
- 전체 버퍼 풀을 위한 메모리 크기가 1GB 미만인 경우 -> 버퍼 풀 인스턴스 1개만 생성
- 전체 버퍼 풀을 위한 메모리 크기가 40GB 이하인 경우 -> 8개
- 40GB보다 큰 경우 -> 버퍼 풀 인스턴스당 5GB 정도 되도록 인스턴스 개수 설정 권장

## 4.2.7.2 버퍼 풀 구조
### InnoDB 버퍼 풀의 페이지
- InnoDB 스토리지 엔진이 데이터를 저장하고 관리하는 기본 단위

### InnoDB 버퍼 풀의 페이지 크기 관리 방법
- LRU(Least Recently Used) 리스트, Flush 리스트, Free 리스트로 관리

### Free 리스트
- InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
- 사용자 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용

### LRU 리스트
<img width="346" alt="Image" src="https://github.com/user-attachments/assets/22647fb1-e6a1-4a16-a933-47070f6dcde6" />

- LRU와 MRU(Most Recently Used)리스트가 결합된 형태
- Old 서브 리스트 = LRU
- New 서브 리스트 = MRU
- **디스크 읽기 최소화가 목표**
 ```
   <InnoDB 스토리지 엔진에서 데이터를 찾는 과정>

   1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
       A. InnoDB 어댑티브 해시 인덱스(자주 사용되는 값을 해시로 사용) 이용
          [참고] https://tech.kakao.com/posts/319
       B. 해당 테이블의 인덱스(B-Tree) 이용
       C. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
   2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
   3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
   4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(age)가 부여되며,
       버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고(aging) 결국 해당 페이지는 버퍼 풀에서 제거된다.
       버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화되어 다시 젊어지고 MRU의 헤더 부분으로 옮겨진다.
   5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가

   => 처음 한 번 읽힌 데이터 페이지가 이후 자주 사용된다면 그 데이터 페이지는 MRU 영역에서 계속 살아남게 되고,
      반대로 거의 사용되지 않는다면 LRU의 끝으로 밀려나 결국은 InnoDB 버퍼 풀에서 제거될 것이다.
   ```

### 플러시 리스트
- 디스크로 동기화 안된 데이터를 가진 데이터 페이지(더티 페이지) 목록 관리
- 데이터 변경 과정:  
    1. 변경 기록: 데이터가 변경되면, InnoDB는 먼저 해당 변경 내용을 리두 로그(Redo Log)에 기록한다.
        - 리두 로그 위치
            - 리두 로그 버퍼에 저장
            - InnoDB 버퍼 풀과 별개
            - 주기적으로 디스크에 있는 리두 로그 파일로 플러시
    2. 메모리 반영: 동시에 버퍼 풀 내의 해당 데이터 페이지에도 변경 내용이 반영된다.
    3. 로그와 페이지의 연결: 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결되어 있어, 시스템 장애 시 데이터 복구를 가능하게 한다.
    4. 플러시 리스트의 역할: 이러한 변경된(더티) 페이지들을 플러시 리스트에 등록해두고, 백그라운드에서 실행되는 플러시 작업(예: checkpoint, background thread)에 의해 주기적으로 디스크에 동기화(flush)된다.

## 4.2.7.3 버퍼 풀과 리두 로그
<img width="232" alt="Image" src="https://github.com/user-attachments/assets/8e2b076d-f20f-425e-9ed0-be659718e726" />

### InnoDB 버퍼 풀로 DB 서버 성능 향상 방법
1. 데이터 캐시 
    - 버퍼 풀의 메모리 공간 늘리기
        - 디스크의 모든 데이터 파일이 버퍼 풀에 적재될 정도의 버퍼 풀 공간인 경우 -> 버퍼 풀 늘려도 성능 향상 X
2. 쓰기 버퍼링

### InnoDB 버퍼풀은 클린 페이지와 더티 페이지 가지고 있음.
- 더티페이지는 디스크와 데이터 상태가 다름 -> 디스크로 기록돼야 함

### 활성 리두 로그
- 리두 로그 파일에서 재사용 불가능한 공간을 뜻한다.

### LSN(Log Sequence Number)
- InnoDB에서 데이터 변경 로그의 순서를 관리하기 위한 고유 번호
- 매번 기록될 때마다 로그 파일 공간은 계속 순환되어 재사용되지만, <br>
  로그 포지션은 계속 증가된 값(LSN)을 가짐.
- 필요성
    - 디스크에 있는 리두 로그 파일이 고정된 크기를 가짐 
    - 따라서 데이터 변경이 계속 발생하면 순환되어 이전 로그가 새로운 로그로 덮어씀
    - InnoDB 스토리지 엔진은 재사용 가능 공간과 불가능 공간을 구분 해야함.

### InnoDB 스토리지 엔진 -> 주기적으로 체크 포인트 발생 -> 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화
- 가장 최근 체크포인트 지점의 LSN (체크 포인트 LSN)
    - InnoDB가 디스크에 안전하게 기록(플러시)한 마지막 리두 로그의 순서 번호를 의미
        - **더티 페이지가 디스크에 플러시 될때가 아니라 리두 로그가 플러시 될 때!**
    - == (디스크의) 활성 리두 로그 공간의 시작점

### checkpoint Age
- 가장 최근에 기록된 리두 로그 엔트리의 LSN - 가장 최근 체크포인트의 LSN
- 활성 리두 로그 공간의 크기

### 체크포인트 발생시
- 체크포인트 LSN보다 작은 리두 로그 엔트리와 관련된 **더티 페이지**는 모두 디스크로 동기화
- 당연히 체크포인트 LSN보다 작은 LSN 값을 가진 리두 로그 엔트리도 디스크로 동기화돼야 함.

### 리두 로그 파일의 크기 선택 방법
- 버퍼 풀의 크기가 100GB 이하인 경우 -> 리두 로그 파일의 전체 크기는 5 ~ 10GB 사이
    - 그 후 필요할 때마다 조금씩 늘려가면서 최적값 찾기




<br>

# 3.2 추가 내용
### 체크포인트
- InnoDB의 데이터 영속성과 빠른 복구를 보장하기 위해, 버퍼 풀에 있는 더티 페이지들을 디스크에 기록하는 작업

### 어댑티브 해시 인덱스

### Read Ahead
- InnoDB의 읽기 동작 중 하나
- Read Ahead는 대량의 데이터를 순차적으로 읽을 때, 앞으로 읽을 데이터 페이지들을 미리 디스크에서 버퍼 풀로 가져오는 기능
- 디스크 접근 지연(latency)을 줄이고, 연속적인 읽기 작업을 빠르게 수행할 수 있다.

### Eviction
- 버퍼 풀에서 데이터 페이지를 삭제해 추가 공간을 확보하는 작업
