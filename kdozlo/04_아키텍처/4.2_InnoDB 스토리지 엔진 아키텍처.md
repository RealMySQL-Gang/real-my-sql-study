# 4.2 InnoDB 스토리지 엔진 아키텍처
<img width="537" alt="Image" src="https://github.com/user-attachments/assets/a3e4e2da-da3c-4eb5-96e8-0da1ee7812a6" />

### InnoDB 스토리지 엔진
- 레코드 기반 잠금 제공
    - 높은 동시성 처리 가능
    - 안정적
    - 성능 뛰어남


## 4.2.1 프라이머리 키에 의한 클러스터링
- InnoDB의 모든 테이블 -> 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장
    - 프라이머리 키 값 순서대로 디스크에 저장
    - 실행 계획에서 기본키는 다른 보조 인덱스보다 비중이 높게 설정된다.
- 세컨더리 인덱스 -> 라이머리 키의 값을 논리적인 주소로 사용
- MyISAM -> 클러스터링 키 지원 X
    - 프라이머리 키와 세컨더리 인덱스의 구조적 차이 X
    - 프라이머리 키 == 유니크 제약을 가진 세컨더리 인덱스
    - 모든 인덱스는 물리적인 레코드의 주소 값(ROWID)를 가짐

## 4.2.2 외래 키 지원
- InnoDB 스토리지 엔지 레벌에서만 외래키 지원
    - MyISAM, MEMORY 테이블에서는 외래키 사용 X
- 외래 키 체크 기능 비활성화 방법
  ```sql
  SET foreign_key_checks=OFF;
  ```
    - `ON DELETE CASCADE`, `ON UPDATE DASCADE` 무시됨
    - 외래 키 관계가 사라지는건 아님. 다만 외래 키 제약 조건 검증을 안할 뿐.

## 4.2.3 MVCC(Multi Version Concurrency Control)



## 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

## 4.2.5 자동 데드락 감지

## 4.2.6 자동화된 장애 복구

## 4.2.7 InnoDB 버퍼 풀
디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간 
- InnoDB 스토리지 엔진에서 가장 핵심적인 부분
- 쓰기 작업을 지연시켜 일괄 작업으로 처리 가능하게 해주는 **버퍼 역할**
- 변경된 데이터를 모아서 처리 -> 랜덤 디스크 작업의 횟수를 줄임

### 4.2.7.1 버퍼 풀의 크기 설정
- 운영체제의 각 클라이언트 스레드가 사용할 메모리 고려해서 설정해야함
    - 스레드 스택이나 힙 같은 OS 레벨의 메모리 영역
- MySQL 서버 내 메모리를 필요로 하는 부분은 크게 없음
    - 하지만 독특한 경우 **레코드 버퍼**가 상당한 메모리를 사용하기도 함
        - 레코드 버퍼: 각 클라이언트 세션에서 데이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간
        - 커넥션이 많고, 사용하는 테이블이 많은 경우
    - MySQL 서버가 사용하는 레코드 버퍼 공간은 별도로 설정 못함
        - 전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 데이블의 개수에 따라 결정
        - 동적으로 해제되기도 함
- MySQL5.7부터 InnoDB 버퍼 풀의 크기 동적으로 조절할 수 있게 개선됨.
    - InnoDB 버퍼 풀의 크기를 작은 값으로 설정 -> 필요에 따라 증가시키면서 사용하는 방법이 좋다.

- InnoDB 버퍼 풀 크기 설정 방법
    1. 이미 MySQL 서버를 사용하고 있는 경우
        - 서버의 메모리 설정을 기준으로 InnoDB 버퍼 풀의 크기 조정
    2. 처음으로 MySQL 서버 준비
        - 공간이 8GB 미만인 경우
            - 50% 정도만 InnoDB 버퍼 풀로 설정
            - 나머지 메모리 공간 -> MySQL 서버와 운영체제, 다른 프로그램 사용 공간으로 확보
        - 공간이 8GB 이상
            - 50%를 InnoDB 버퍼 풀로 설정 -> 조금씩 올려주면서 최적점 찾기
        - 공간이 50GB 이상
            - 15GB ~ 30GB 정도  MySQL 서버와 운영체제, 다른 프로그램 사용 공간으로 확보
            - 나머지는 전부 InnoDB 버퍼 풀로 할당
    - `innodb_buffer_pool_size`로 크기 설정 가능
    - 버퍼 풀 변경은 크리티컬한 변경 -> MySQL 서버가 한가할 때 하자!
    - 버퍼 풀 크기 줄이는 작업은 지양하자!
        - 늘리는건 시스템 영향도 안큼
        - 줄이는건 서비스 영향도가 매우 큼
    - InnoDB 버퍼 풀 변경 단위 크기: 128MB
    - [버퍼 풀 크기 설정 메뉴얼](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool-resize.html) 

### 버퍼 풀 인스턴스
- InnoDB 버퍼 풀(데이터 캐시 역할을 하는 메모리 영역)을 여러 개의 하위 영역으로 나눈 것
- 내부 잠금 경합 문제를 줄여줌
- 기본적으로 8개로 초기화
- 전체 버퍼 풀을 위한 메모리 크기가 1GB 미만인 경우 -> 버퍼 풀 인스턴스 1개만 생성
- 전체 버퍼 풀을 위한 메모리 크기가 40GB 이하인 경우 -> 8개
- 40GB보다 큰 경우 -> 버퍼 풀 인스턴스당 5GB 정도 되도록 인스턴스 개수 설정 권장

## 4.2.7.2 버퍼 풀 구조
### InnoDB 버퍼 풀의 페이지
- InnoDB 스토리지 엔진이 데이터를 저장하고 관리하는 기본 단위

### InnoDB 버퍼 풀의 페이지 크기 관리 방법
- LRU(Least Recently Used) 리스트, Flush 리스트, Free 리스트로 관리

### Free 리스트
- InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
- 사용자 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용

### LRU 리스트
<img width="346" alt="Image" src="https://github.com/user-attachments/assets/22647fb1-e6a1-4a16-a933-47070f6dcde6" />

- LRU와 MRU(Most Recently Used)리스트가 결합된 형태
- Old 서브 리스트 = LRU
- New 서브 리스트 = MRU
- **디스크 읽기 최소화가 목표**
 ```
   <InnoDB 스토리지 엔진에서 데이터를 찾는 과정>

   1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
       A. InnoDB 어댑티브 해시 인덱스(자주 사용되는 값을 해시로 사용) 이용
          [참고] https://tech.kakao.com/posts/319
       B. 해당 테이블의 인덱스(B-Tree) 이용
       C. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
   2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
   3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
   4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(age)가 부여되며,
       버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고(aging) 결국 해당 페이지는 버퍼 풀에서 제거된다.
       버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화되어 다시 젊어지고 MRU의 헤더 부분으로 옮겨진다.
   5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가

   => 처음 한 번 읽힌 데이터 페이지가 이후 자주 사용된다면 그 데이터 페이지는 MRU 영역에서 계속 살아남게 되고,
      반대로 거의 사용되지 않는다면 LRU의 끝으로 밀려나 결국은 InnoDB 버퍼 풀에서 제거될 것이다.
   ```

### 플러시 리스트
- 디스크로 동기화 안된 데이터를 가진 데이터 페이지(더티 페이지) 목록 관리
- 데이터 변경 과정:  
    1. 변경 기록: 데이터가 변경되면, InnoDB는 먼저 해당 변경 내용을 리두 로그(Redo Log)에 기록합니다.
        - 리두 로그 위치
            - 리두 로그 버퍼에 저장
            - InnoDB 버퍼 풀과 별개
            - 주기적으로 디스크에 있는 리두 로그 파일로 플러시
    2. 메모리 반영: 동시에 버퍼 풀 내의 해당 데이터 페이지에도 변경 내용이 반영됩니다.
    3. 로그와 페이지의 연결: 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결되어 있어, 시스템 장애 시 데이터 복구를 가능하게 합니다.
    5. 플러시 리스트의 역할: 이러한 변경된(더티) 페이지들을 플러시 리스트에 등록해두고, 백그라운드에서 실행되는 플러시 작업(예: checkpoint, background thread)에 의해 주기적으로 디스크에 동기화(flush)됩니다.

<br>

# 3.2 추가 내용
### 체크포인트
- InnoDB의 데이터 영속성과 빠른 복구를 보장하기 위해, 버퍼 풀에 있는 더티 페이지들을 디스크에 기록하는 작업
